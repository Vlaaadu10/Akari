# **This document contains the explanations for the implementation of the theme 1 of the Computer Programming and Programming Languages ​​I course. Below you will find the description of the concepts and functions used in the three problems. In addition, the implementations are modular, each problem uses separate functions for the main operations.**
314CA Stefan Alexandru Vladut

## **Problem 2: Akari**
The Akari problem requires the implementation of two options: Grid Completion (Option 1) and Grid Validation (Option 2). The grid is indexed from 0 and is represented as a character matrix.

**Option 1: Grid Completion**
- The grid is traversed only once.
- For each bulb (L), the function cover_bulb is called to propagate the light.
- For each numbered cell (0-4), the function cover_black_cell is called. This marks adjacent empty (‘-’) cells with ‘x’ only if the number of adjacent bulbs is exactly the number required by the cell.

**Option 2: Grid Validation**
- Pre-validation: We used a do-while loop to apply the functions cover_bulb and cover_black_cell iteratively, until no more changes are made. This ensures that all blocked or illuminated cells are marked with ‘x’.
- Final check: We walk through the grid to check the two Akari rules:
- Adjacent bulbs: Call the check_bulb function for each L (they must not light each other).
- Numbered cells: Call the check_black_cell function for each 0-4 (the number of adjacent bulbs must not exceed the required number, and the number of adjacent bulbs + empty cells must be greater than or equal to the required number).

**Implemented functions**

`cover_bulb`
- Parameters: int i, int j(bulb coordinates), char a[][NMAX] (grid), int n, int m(dimensions)
- Returns int(1 if changes were made, 0 otherwise)
- Mode of operation: Propagate light(‘x’) horizontally and vertically from (i,j), stopping at black blocks or edges

`cover_black_cell`
- Parameters: int i, int j(cell coordinates), char a[][NMAX] (grid), int n, int m(dimensions)
- Returns int(1 if changes were made, 0 otherwise)
- Mode of operation: Marks adjacent white cells with ‘x’ if the number of adjacent bulbs is equal to the value of the numbered cell.

`verif_bec`
- Parameters: int i, int j(coordinates of the bulb), char a[][NMAX], int n, int m
- Returns int (0 if the bulb violates the rule, 1 otherwise)
- Mode of operation: checks if the bulb at (i,j) illuminates another bulb without an intermediate black block

`verif_cel_negre`
- Parameters: int i, int j(coordinates of the cell), char a[][NMAX], int n, int m
- Returns int (0 if the cell violates the rule, 1 otherwise)
- Mode of operation: checks if the number of adjacent bulbs is compatible with the number on the cell, taking into account free cells(‘-’).
